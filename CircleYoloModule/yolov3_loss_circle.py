# -*- coding: utf-8 -*-
"""yolov3_loss_circle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IbKWoIPbKHWKjTcmRMtwEsPZEoEsGOkV
"""
import torch
import torch.nn as nn
from .circle_intersection_over_union import intersection_over_union

class YoloV3LossCircle(nn.Module):
  def __init__(self, lambda_noobj: float = 10, lambda_box: float = 10, lambda_class: float = 1, lambda_obj: float = 1):
    super().__init__()
    self.mse = nn.MSELoss()
    self.bce= nn.BCEWithLogitsLoss()
    self.entropy = nn.CrossEntropyLoss()
    self.sigmoid = nn.Sigmoid()

    self.lambda_class = lambda_class
    self.lambda_obj = lambda_obj
    self.lambda_noobj = lambda_noobj
    self.lambda_box = lambda_box

  def forward(self, predictions, target, anchors):
    # Check where obj and noobj (we ignore if target == -1), figure masks
    obj = target[..., 0] == 1 # in paper this is Iobj_i
    noobj = target[..., 0] == 0 # in paper this is Inoobj_i

    #NO OBJECT LOSS
    no_object_loss = self.bce(
        (predictions[..., 0:1][noobj]), (target[..., 0:1][noobj]),
    )

    #OBJECT LOSS
    anchors = anchors.reshape(1, 1, 1, 1, 1) # 3x1 (last 1) >>> p_r * exp(t_r)
    circle_pred = torch.cat([self.sigmoid(predictions[..., 1:3]), torch.exp(predictions[..., 3:4] * anchors)], dim = -1) # (1, 1, 13, 13, 1) * (1, 1, 1, 1, 1)
    ious = intersection_over_union(circle_pred[obj], target[..., 1:4][obj]).detach()
    object_loss = self.mse((predictions[..., 0:1][obj]), (ious * target[..., 0:1][obj]))

    #BOX AND CORD LOSS
    predictions[..., 1:3] = self.sigmoid(predictions[..., 1:3]) #X, Y cords
    target[..., 3:4] = torch.log(
        (1e-16 + target[..., 3:4] / anchors)
    ) #r cord
    box_loss = self.mse(predictions[..., 1:4][obj], target[..., 1:4][obj])

    #CLASS LOSS
    class_loss = self.entropy(
        (predictions[..., 4:][obj]), (target[..., 4][obj].long()),
    )
    return (
        self.lambda_box * box_loss
        + self.lambda_obj * object_loss
        + self.lambda_noobj * no_object_loss
        + self.lambda_class * class_loss
    )